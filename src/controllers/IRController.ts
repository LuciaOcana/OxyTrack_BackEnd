// src/controllers/IRController.ts
import { Request, Response } from 'express';
import { clients } from '../index';
import { insertSpO2ToSheet, insertIRRedToSheet } from '../services/googleSheetsService';

export const ANALYSIS_WINDOW_SIZE = 5; // N¬∫ de muestras necesarias para calcular SpO‚ÇÇ
export const CALCULATION_INTERVAL_MS = 120000; // Intervalo de c√°lculo (2 minutos)

let measurementBatch: { ir: number; red: number }[] = [];
let latestSpO2: number | null = null;
export let activeUsername: string | null = null;

// Validaci√≥n de variable de entorno
const SHEET_ID = process.env.GOOGLE_SHEETS_ID;
if (!SHEET_ID) {
  throw new Error('‚ùå GOOGLE_SHEETS_ID no est√° definida en el entorno');
}

/**
 * Procesa cada muestra IR/RED recibida desde el ESP32
 */
export async function processSample(ir: number, red: number): Promise<void> {
  measurementBatch.push({ ir, red });
  console.log(`üì• Muestra recibida: IR=${ir}, RED=${red}`);

  if (activeUsername) {
    try {
      await insertIRRedToSheet(activeUsername, ir, red, SHEET_ID!, 'IR_RED');
    } catch (err) {
      console.error('‚ùå Error guardando IR/RED en Google Sheets:', err);
    }
  }
}

/**
 * Calcula la media de un array num√©rico
 */
function mean(arr: number[]): number {
  return arr.reduce((sum, val) => sum + val, 0) / arr.length;
}

/**
 * Estima el valor de SpO‚ÇÇ a partir de arrays IR y RED
 */
function estimateSpO2(ir: number[], red: number[]): number | null {
  const irAC = Math.max(...ir) - Math.min(...ir);
  const redAC = Math.max(...red) - Math.min(...red);
  const irDC = mean(ir);
  const redDC = mean(red);

  if (irDC === 0 || redDC === 0 || irAC === 0 || redAC === 0) {
    return null;
  }

  const ratio = (redAC / redDC) / (irAC / irDC);
  const spo2 = 110 - 25 * ratio;
  return Math.min(100, Math.max(0, Math.round(spo2)));
}

/**
 * Intervalo peri√≥dico para calcular SpO‚ÇÇ y enviarlo a Google Sheets + WebSocket
 */
setInterval(async () => {
  if (measurementBatch.length < ANALYSIS_WINDOW_SIZE) {
    console.log(`‚è≥ Esperando m√°s muestras... (${measurementBatch.length}/${ANALYSIS_WINDOW_SIZE})`);
    return;
  }

  const irs = measurementBatch.map(m => m.ir);
  const reds = measurementBatch.map(m => m.red);
  const spo2 = estimateSpO2(irs, reds);

  if (spo2 === null) {
    console.log('üö´ No se pudo calcular SpO‚ÇÇ por datos inv√°lidos.');
    measurementBatch = [];
    return;
  }

  latestSpO2 = spo2;
  console.log(`ü©∏ SpO‚ÇÇ estimado: ${latestSpO2}%`);

  if (activeUsername) {
    try {
      await insertSpO2ToSheet(activeUsername, latestSpO2, SHEET_ID, 'SpO2');
    } catch (err) {
      console.error('‚ùå Error guardando SpO‚ÇÇ en Google Sheets:', err);
    }
  }

  const data = {
    username: activeUsername,
    spo2: latestSpO2,
    timestamp: new Date().toISOString(),
  };

  clients.forEach(ws => {
    if (ws.readyState === ws.OPEN) {
      ws.send(JSON.stringify(data));
    }
  });

  measurementBatch = [];
}, CALCULATION_INTERVAL_MS);

/**
 * Inicia la medici√≥n para un usuario
 */
export function startMeasurementInternal(username: string) {
  activeUsername = username;
  console.log(`üë§ Usuario activo: ${username} ‚Äî medici√≥n iniciada`);
}

/**
 * Devuelve el √∫ltimo valor de SpO‚ÇÇ calculado
 */
export function getLatestSpO2(req: Request, res: Response) {
  if (latestSpO2 === null) {
    res.status(404).json({ message: 'No hay datos suficientes para calcular SpO‚ÇÇ todav√≠a' });
    return;
  }
  res.status(200).json({ spo2: latestSpO2 });
}

/**
 * Establece el usuario activo
 */
export function setActiveUsername(username: string) {
  activeUsername = username;
}

/**
 * Devuelve el usuario activo actual
 */
export function getActiveUsername() {
  return activeUsername;
}
